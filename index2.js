/*
 * @Date: 2021-07-12 13:56:39
 * @LastEditors: bujiajia
 * @LastEditTime: 2021-07-19 18:47:19
 * @FilePath: /test/index2.js
 */

/////////////////////////////////////////////////////前端储存，cookie,session,localstorage,indexdb
//cookie：用来验证网站用户身份的，只有4KB，容量小。同域名每次请求的时候都带上，服务器set-cookie来设置cookie。name=value,domain制定cookie域名，path，制定cookie在哪个路径下，默认和/，maxage失效时间，单位是秒，在maxage秒后失效，默认是-1.表示浏览器关闭后即删除cookie。expires过期时间，在设置的某个时间后自动失效。
//storage 只有5m大小，而且只能存字符串，需要通过stringify
//session是储存在服务端的，客户端储存一个sessionid，
//token是储存在客户端的，服务端不存，每次客户端请求的时候带过来，服务端用解析时间换取储存空间。
//jwt。和session差不多，但是session每次都要服务器从数据库查询数据，而jwt可以直接解析出来用户信息。

//tcp/ip的四层模型，应用层，会话层，传输层，链路层

//三次握手，每次握手seq序列号都要+1，ACK=1时表示确认序列号有效。ack为接收的seq+1,握手时发送SYN,挥手时发送FIN。主要是为了确认客户端和服务器双方的接收和发送能力正常。连接服务器端口，简历tcp链接，同步双方序列号和确认号。第一二次握手不能带数据，第三次可以带数据。第一次：客户端发送seq=x,syn=1,第二次：服务端发送ACK=1,seq=y,ack=x+1,SYN=1,第三次:客户端发送ACK=1,seq=x+1,ack=y+1

//syn攻击，，第二次握手的时候服务器是SYN_RCVD 状态，但是已经资源分配了。客户端不管服务端的状态大量伪造ip向服务器发送syn包，服务器端则不断回复确认包，并等待客户端确认，但是客户端源地址并不存在，所以服务端等待不断超时，导致正常的syn请求因为队列满了被丢弃。从而引起网络拥堵甚至瘫痪。是一种典型的dos/ddos攻击。 应对方法1：缩短超时时间，增加最大半连接数，过滤网关防护，syn cookies。

//四次挥手，1：客户端发送请求报文FIN=1和序列号seq=u， 2：服务端接收fin,发送ACK=1.ack=u+1,seq=v， 3：服务端发送完成后，也想断开了发送FIN=1,ACK=1,seq=w,ack=u+1，4：客户端接收FIN后，发送ACK=1,seq=u+1,ack=w+1

//总结 握手挥手：因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

//http状态码，https://juejin.cn/post/6844904113180786696  304可以直接从客户端使用未过期缓存。301永久重定向，302临时重定向，表示请求的资源已经永久性分配了新的URI，以后应该使用该新的URI。 使用Location首部字段表示新URI地址。浏览器会重新请求一次该URI。401未认证，403禁止访问，404 Notfound，500服务器内部错误。503服务不可用，101 Switching Protocols。在HTTP升级为WebSocket的时候，如果服务器同意变更，就会发送状态码 101。

//////http报文结构：
//起始行 GET /home HTTP/1.1   方法 + 路径 + http版本。
//头部

/////大文件上传，断点续传。主要靠分片处理  https://juejin.cn/post/6844904046436843527，https://juejin.cn/post/6844903968338870285#heading-17  断点续传用spark-mds包来生成hash,将上传成功的分片保存在本地，

// http1和http2区别。http1对同一个域名下的请求有数量限制，可能导致请求阻塞。提供了多个静态资源的CDN域名，目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。  http2有多路复用。 http1的头部一直是纯文本，而http2头部用二进制，http2会把头部压缩减少头部大小。速度更快。

/////////////////////////////////////////////////////// http  https
// http:端口是80，运行在tcp上。  https运行在ssl/tls上
// https:端口是83，多了一个tls(ssl)一个安全套接层，所谓HTTPS其实就是身披SSL协议外壳的HTTP，必须从CA申请一个证书，证书有CA的签名，客户端才知道主机是安全的。客户端和服务器有秘钥和私钥，加密数据。简而言之HTTPS = HTTP+认证+加密+完整性保护。但是https会因为多使用ssl速度变慢，通信慢，加上加密解密cpu负载增大导致处理速度变慢。在一个就是购买证书会导致成本增加。https可以防止运营商劫持。

//tcp和udp的区别，udp是不需要连接的，没有三次握手，不会对报文进行拆分和拼接。其实udp就是数据报文的搬运工。  1：在发送端，引用层将数据报文添加一个udp头表示下这是udp协议，然后发给网络层，2：在接收端，网络层将数据传输给传输层，udp只去吃ip报文头。不会进行任何拼接操作。
//udp：一对一或者一对多，无须握手连接，面向报文。不可靠传输，适用于ip电话，视频会议，直播等。首部开销比较小，8字节。
//tcp:一对一，需要握手连接，可靠传输，使用流量控制和拥塞控制。面向字节流。首部开销最小20字节，最大60字节。 适用于可靠传输的应用，比如文件传输。
//http优化，gzip，见效静态资源大小，合并http请求。静态资源缓存，头部压缩。http2的多路复用，使一个Tcp连接能处理多个请求。cdn加速。dns预加载

// expires 资源过期时间
// cache-control 请求响应头 精准控制缓存策略，如果没有这个就看expires

// if-modifiled-since 最近修改时间 请求头
// last-modefield last-modefield

// etag 资源标识 响应头
// if-no-match 缓存资源标识 请求头
